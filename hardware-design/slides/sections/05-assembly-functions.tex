\Section{Assembly Functions}


\Subsection{The Stack}

\begin{frame}{Push and Pop}

	When a program starts running, the OS loads the instructions into memory.

	It also allocates memory for the program to use during execution

	There is a special register called the stack pointer which provides the location of that memory

\end{frame}


\begin{frame}{Working Memory}
	\begin{columns}
		\begin{column}{0.5\textwidth}

			we do not know what piece of memory the OS will provide

			arbitrarily say it starts at 0x5000

			stack pointer points to the "bottom" of our available memory. we work our way "up" by subtracting from the stack pointer

			The rules are the same when we call a function. It looks at SP to know the "bottom" of its available memory, then works up from there

		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{ r | l }
					0x4ff8 & \vdots           \\
					0x4ffc & available        \\
					0x5000 & available        \\
					0x5004 & in use by parent \\
					0x5008 & in use by parent \\
					0x500c & \vdots           \\
				\end{tabular}
			\end{alltt}
		\end{column}
	\end{columns}

\end{frame}


\Subsection{Calling a Function}


\begin{frame}{Branch and Link}

	New command: BL

	Branch and Link

	Branch = modify PC. Recall: PC tells us what to do next. Usually we just do the next line. In this case, we will jump to some other part of the program. This is how we call a function.

	Link = set LR to the PC of the next line. Once we're done with the function, this is how we return to the parent context.

\end{frame}

\Subsection{Stack Frames}


\begin{frame}{Frame Pointer}

	\begin{itemize}
		\item Not strictly necessary
		\item Code is easier to read
		\item Integration with debugging tools
		\item Stack pointer can move during the function
		\item Skipping the frame pointer can be skipped by some compilers
	\end{itemize}

	% https://stackoverflow.com/questions/46797915/what-are-the-advantages-of-a-frame-pointer

\end{frame}


\begin{frame}{SIMD}

	\begin{itemize}
		\item SIMD - single instruction, multiple data
		\item 64 bit architecture (8 bytes)
		\item there are cases where it works in chunks of 16 bytes
		\item I don't have time to worry about that, and neither do you. For the purposes of this class, everything is 16 bytes.
		\item This is wasteful! We are using double the memory we need, sometimes more
		\item That's ok. We are not trying to become assembly developers. We are getting exposure to important concepts
	\end{itemize}

\end{frame}



\begin{frame}{Stack Frame Walkthrough}
	\small
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{r | l}
					       & {\quad}.section .rodata \\
					       &                         \\
					       & {\quad}.text            \\
					       & func:                   \\
					0x3fd4 & {\quad}push \{fp, lr\}  \\
					0x3fd8 & {\quad}add fp, sp, \#4  \\
					0x3fdc & {\quad}sub sp, sp, \#4  \\
					0x3fe0 & {\quad}@ ...            \\
					0x3fe4 & {\quad}sub sp, fp, \#4  \\
					0x3fe8 & {\quad}pop \{fp, pc\}   \\
					       &                         \\
					       & {\quad}.global main     \\
					       & main:                   \\
					0x3fec & {\quad}push \{fp, lr\}  \\
					0x3ff0 & {\quad}add fp, sp, \#4  \\
					0x3ff4 & {\quad}sub sp, sp, \#8  \\
					0x3ff8 & {\quad}bl func          \\
					0x3ffc & {\quad}sub sp, fp, \#4  \\
					0x4000 & {\quad}pop \{fp, pc\}   \\
				\end{tabular}
			\end{alltt}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{ r | l}
					\vdots & \vdots    \\
					0x4ffc & available \\
					0x5000 & available \\
					0x5004 & in use    \\
					\vdots & \vdots    \\
				\end{tabular}
			\end{alltt}

			\vspace{1cm}

			\begin{alltt}
				\begin{tabular}{ r | l}
					sp & 0x5004    \\
					fp & parent fp \\
					pc & 0x3fec    \\
					lr & parent lr \\
				\end{tabular}
			\end{alltt}
		\end{column}
	\end{columns}

\end{frame}

\Subsection{Local Variables}


\begin{frame}{Local Variables}
	\begin{itemize}
		\item LDR from an address
		\item STR to an address
		\item Offsets from SP and FP
	\end{itemize}
\end{frame}

