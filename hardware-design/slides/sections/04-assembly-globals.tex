\Section{Assembly Globals}

\begin{frame}{Coding in Assembly}
	\begin{itemize}
		\item We'll be doing some coding exercises in Assembly (specifically aarch64) on emulators and on a Raspberry Pi
		\item Assembly code can be super efficient. Ours won't be.
		\item We are not studying to become assembly developers. We are here for the core concepts
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Hello World in C}
	\begin{minted}{C}
		#include <stdio.h>
		int main() {
			printf("Hello world!\n");
			return 0;
		}
	\end{minted}

	Your local C compiler can turn this into an executable, which you can then run:

	\begin{minted}{bash}
		$ gcc hello.c
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Hello World in Python}
	\begin{minted}{python}
		print('Hello world!')
	\end{minted}

	You can run this using your local Python interpreter:
	\begin{minted}{bash}
		$ python3 hello.py
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Hello World in Assembly}
	% haven't yet found a perfect highlighter match
	% tasm - pretty good, does not like //
	% gas - does not like = for globals
	% nasm - does not like // or =
	% ca65 - comments and a lot of commands all black
	% llvm, dasm16, hsail - nope
	% C, actionscript, ada, asn1, r, ...
	\begin{minted}{arm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			b exit
	\end{minted}

	You can assemble this into an executable and run it on your Raspberry Pi:
	\begin{minted}{bash}
		$ gcc hello.s
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item It takes a lot of lines to do anything
		\item There is so much boilerplates
		\item Yikes
	\end{itemize}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item An Intel CPU and an AMD CPU can both run the same logic, but they will do things in slightly different ways.
		\item When coding in C, you (mostly) don't have to worry about it. The compiler makes your logic work on the current hardware.
		\item Same for Python. The interpreter (itself compiled) figures it out.
		\item Assembly is not like that. Intel assembly is tied to the hardware specifics of the Intel CPU. ARM assembly is a different language.
		\item We study Assembly because we want to talk about what is happening on hardware.
	\end{itemize}

	%	The following command compiles a program in C:
	%	\begin{minted}{bash}
	%		gcc hello.c -o hello
	%	\end{minted}
	%	This creates several intermediate files, eventually creating an executable file (which we can run).
	%	`hello.c' -> preprocessor -> `hello.i' -> compiler -> `hello.s' -> assembler -> `hello.o' -> linker -> `hello'

\end{frame}

% per wikipedia:
% Each computer architecture has its own machine language. Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.

%\Subsection{Registers and Memory}

%\begin{frame}{Registers and Memory}
%We'll dig deeper into the hardware later. For now, let's just look at three new terms:
%	\begin{itemize}
%		\item The \textbf{CPU} is where computations actually happen.
%		\item The CPU includes tiny bits of storage for the values it's using right now. These are called \textbf{registers}.
%		\item All other data is stored in \textbf{memory} (aka RAM). This includes data as well as the program instructions themselves.
%		\item When coding in C or Python, you do not need to worry about registers. You declare variables and the computer figures it out.
%		\item When coding in Assembly, we manually move data back and forth between memory and registers.
%	\end{itemize}
%\end{frame}

\Subsection{Assembly Program Structure}

\begin{frame}{Assembly Program Structure}
	Specifically Aarch64, sometimes called ARM v8
\end{frame}

\begin{frame}[fragile]{Assembly Boilerplate}
	The Assembly programs we write in this course will look like this:
	\begin{minted}{arm}
		.section .rodata
			// global constants
		
		.section .data
			// global variables
		
		.section .text
		.global main
		main:
			// execution starts here

			// return 0 (normal exit status)
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}{Formatting Your Code}
	\begin{itemize}
		\item Work in lowercase by convention, but uppercase mostly works too
		\item Indentation and line breaks can help with legibility
		\item Any line that starts with \Arm{//} is a comment
		\item Question: how many comments should your code include?
	\end{itemize}
\end{frame}


%\begin{frame}{Expectations for Comments}
%	\begin{itemize}
%		\item Any time you 
%	\end{itemize}
%\end{frame}

\begin{frame}[fragile]{Global Constants}
	\begin{minted}{arm}
		.section .rodata
			prompt: .ascii "how many koalas do you have? \0"
			digits_per_hand: .word 5
		\end{minted}
	\begin{itemize}
		\item Value is allocated at the start of the program
		\item Use the variable name to load the \emph{address}
		\item Value does not change
		\item Types we will use: \Arm{word} and \Arm{ascii}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Main}
	\begin{minted}{arm}
		.section .text
		.global main
		main:
			ldr x0, =message
			bl printf
			mov x0, 0
			b exit
		\end{minted}
	\begin{itemize}
		\item If using a different compiler, you may need to swap \Arm{main} to \Arm{_start} or similar
		\item We'll talk about instructions (\Arm{ldr}, \Arm{bl}, etc) next
		\item Return 0 unless you are trying to indicate a failure
	\end{itemize}
\end{frame}

\Subsection{Assembly Commands}

\begin{frame}{Register Names}
	\begin{itemize}
		\item The 64-bit registers in aarch64 are named \Arm{x0}, \Arm{x1}, etc
		\item If you see \Arm{w0}, that's the lower 32 bits of \Arm{x0}
		\item If you see \Arm{r0}, it's probably a typo left over from the previous version of this class
	\end{itemize}
\end{frame}

\begin{frame}{Memory Diagrams}
Just the registers for now

These will get more interesting when we start talking about local variables
\end{frame}


\begin{frame}{Don't Worry!}
	\begin{itemize}
		\item We are just looking at these to get a feel for them
		\item You will have plenty of time to practice
		\item You do not need to worry about memorizing anything right now
	\end{itemize}
\end{frame}

\begin{frame}{Basic Commands in Assembly}
	\begin{itemize}
		\item \Arm{... // double slash for inline comments}
		\item \Arm{add x0, x1, 5 // add x1 + 5, store in x0}
		\item \Arm{add x0, x1, x7 // add x1 + x7, store in x0}
		\item \Arm{mov x4, 5 // set x4 = 5 (literal number)}
		\item \Arm{mov x4, x5 // set x4 = x5}
		\item \Arm{mul x2, x8, x3 // multiply x8 * x3, store in x2}
		\item \Arm{mul x2, x8, 12 // multiply x8 * 12, store in x2}
		\item \Arm{sub x5, x4, 3 // subtract x4 - 3, store in x5}
		\item \Arm{sub x5, x4, x3 // subtract x4 - x3, store in x5}
	\end{itemize}
\end{frame}


\begin{frame}[fragile]{Reading from Memory}
	Load the \emph{address} of global variable \Arm{fizz} to \Arm{x3}:
	\begin{minted}{arm}
		ldr x3, =fizz
	\end{minted}

	Register \Arm{x2} holds an \emph{address}. Load the \emph{value} to \Arm{x3}:
	\begin{minted}{arm}
		ldr x3, [x2]
	\end{minted}

	Register \Arm{x2} holds an \emph{address}. Load the \emph{value} from \Arm{x2-0x20} to \Arm{x3}:
	\begin{minted}{arm}
		ldr x3, [x2, -0x20]
	\end{minted}

	Global variable \Arm{fizz} holds a number. Load the address, then load the value from that address:
	\begin{minted}{arm}
		ldr x3, =fizz
		ldr x3, [x3] // yes it can be the same register
	\end{minted}

\end{frame}


\begin{frame}[fragile]{Writing to Memory}

	Register \Arm{x5} holds an \emph{address}. Store the \emph{value} from \Arm{x7} to that address:
	\begin{minted}{arm}
		str x7, [x5]
	\end{minted}

	\vspace{0.5cm}

	Register \Arm{x5} holds an \emph{address}. Store the \emph{value} from \Arm{x8} to \Arm{x5+0x10}
	\begin{minted}{arm}
		str x7, [x5, 0x10]
	\end{minted}
\end{frame}

\begin{frame}[fragile]{We'll talk more about these ones later}
	Call the function \Arm{printf}, which prints output to the terminal:
	\begin{minted}{arm}
		bl printf
	\end{minted}

	\vspace{0.3cm}

	Call the function \Arm{exit}, which exits the program:
	\begin{minted}{arm}
		b exit
	\end{minted}

	\vspace{0.3cm}
	\Arm{b} is "branch". \Arm{bl} is "branch and link". We'll get into these later
\end{frame}

\Subsection{Printf}

\begin{frame}[fragile]{Printf in C}
	\begin{itemize}
		\item We use \texttt{printf} to print output to the terminal in Assembly
		\item Let's look at C first. The functionality is the same and C is more legible
	\end{itemize}

	\begin{minted}{C}
		const char* name = "charles";
		printf("hello my name is %s\n", name);
	\end{minted}

	\begin{minted}{C}
		const int m = 2, n = 3;
		int s = m + n;
		printf("%d + %d = %d\n", m, n, s);
	\end{minted}
\end{frame}

\begin{frame}{What does it do?}
	\begin{itemize}
		\item The first argument to \texttt{printf} must be a string
		\item The string can include format specifiers like \texttt{\%d}
		\item Subsequent arguments are inserted into the string (in order) in place of the format specifiers
	\end{itemize}
\end{frame}

\begin{frame}{Format Specifiers}
	\begin{itemize}
		\item \texttt{\%d} - interpret the value as an integer
		\item \texttt{\%c} - interpret the value as an ASCII character
		\item \texttt{\%s} - interpret the value as a \emph{pointer} to a null-terminated string
		\item These values are just ones and zeroes! You can use whichever format speficier you want. But you might not like the results
		\item Why do we use a pointer to the string instead of the string itself?
	\end{itemize}
\end{frame}

% more about format specifiers: https://www.geeksforgeeks.org/c/format-specifiers-in-c/

\begin{frame}{Calling Printf in Assembly}
	We'll get deeper into function calls later. For now:
	\begin{itemize}
		\item \Arm{printf} is a function
		\item \Arm{bl printf} is how we call it
		\item \Arm{printf} looks at \Arm{x0} for its first argument (the output string)
		\item if the output string includes a format identifier, it grabs the value from \Arm{x1}
		\item if the output string includes another format identifier, it grabs the value from \Arm{x2}, etc
		\item Format identifiers in Assembly are the same as those in C
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 1}
	\begin{minted}{arm}
		.section .rodata
			output: .ascii "hello my name is %s\n\0"
			name: .ascii "charles\0"

		.section .text
		.global main
		main:
			ldr x0, =output
			ldr x1, =name
			bl printf
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 2}
	\begin{minted}{arm}
		.section .rodata
			output_str: .ascii "the current year is %d\n\0"
			current_year: .word 2026
		
		.section .text
		.global main
		main:
			ldr x0, =output_str
			ldr x1, =current_year
			ldr x1, [x1]
			bl printf
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 3}
	\begin{minted}{arm}
	.section .rodata
		output_str: .ascii "%d + %d = %d\n\0"
	
	.section .text
	.global main
	main:
		ldr x0, =output_str
		mov x1, 2
		mov x2, 3
		add x3, x1, x2
		bl printf
		mov x0, 0
		b exit
	\end{minted}
\end{frame}

\Subsection{Scanf}

\begin{frame}[fragile]{Minimal Read}
	\begin{minted}{arm}
		.section .rodata
			input_fmt: .ascii "%d\0"
		.section .data
			input_val: .word 0
		.section .text
		.global main
		main:
			ldr x0, =input_fmt
			ldr x1, =input_val
			bl scanf
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}[fragile]{More Useful Read}
	\begin{small}
		\begin{minted}{arm}
		.section .rodata
			prompt: .ascii "Please enter a number: \0"
			report: .ascii "You entered %d\n\0"
			input_fmt: .ascii "%d\0"
		.section .data
			input_val: .word 0
		.section .text
		.global main
		main:
			ldr x0, =prompt
			bl printf
			ldr x0, =input_fmt
			ldr x1, =input_val
			bl scanf
			ldr x1, =input_val
			ldr x1, [x1]
			ldr x0, =report
			bl printf
			mov x0, 0
			b exit
	\end{minted}
	\end{small}
\end{frame}

\Subsection{Automated Testing}

\begin{frame}{Expectations on Assignments}
	\begin{itemize}
		\item Every piece of code you turn in should come with a test
		\item Make sure it compiles
		\item Provide example input, check the output
		\item Tests will be shell scripts
		\item I will provide a template
	\end{itemize}
\end{frame}

\begin{frame}{Why Test?}
	\begin{itemize}
		\item Code is often modified by someone other than the original author
		\item Code is often modified long after the original context is forgotten
		\item Non-obvious program behavior may be (or become) important
		\item Documentation can easily be outdated and/or ignored
		\item Automated tests make noise before breaking changes are committed
		\item They also act as live documentation
	\end{itemize}
\end{frame}


\begin{frame}{Why Shell?}
	\begin{itemize}
		\item Many languages have built-in test frameworks. Assembly doesn't. We're improvising
		\item Shell scripting uses familiar syntax (ls, gcc)
		\item You are welcome to copy-paste from my example
		\item I tried Python last time. It was more work. You are welcome to try it again!
	\end{itemize}
\end{frame}



\begin{frame}[fragile]{Why Bash?}
	\begin{minted}{bash}
		#!/usr/bin/bash
		set -e

		function run_and_check {
			local TEST_CASE_NAME="$1"
			local INPUT="$2"
			local EXPECTED_OUTPUT="$3"
			ACTUAL_OUTPUT=$(echo "$INPUT" | ./a.out) ||:
			if [[ "$EXPECTED_OUTPUT" != "$ACTUAL_OUTPUT" ]]; then
				echo "$TEST_CASE_NAME - expected \"$EXPECTED_OUTPUT\" but got \"$ACTUAL_OUTPUT\""
			else
				echo "$TEST_CASE_NAME - ok"
			fi
		}
		
		
		# Case 0: compile the code
		CASE_NAME="compile"
		rm a.out ||:
		gcc add_two.s 
		if [[ "$?" == "0" || -f a.out ]]; then 
			echo "$CASE_NAME - ok"
		else
			echo "$CASE_NAME - build failed"
		fi
		
		# Case 1: small positive ints
		CASE_NAME="positive"
		INPUT="3
		4"
		EXPECTED_OUTPUT="Enter a number: Enter a number: Sum: 7"
		run_and_check "$CASE_NAME" "$INPUT" "$EXPECTED_OUTPUT"
		
		# Case 2: sum to zero
		CASE_NAME="opposite"
		INPUT="-3
		3"
		EXPECTED_OUTPUT="Enter a number: Enter a number: Sum: 0"
		run_and_check "$CASE_NAME" "$INPUT" "$EXPECTED_OUTPUT"
		
		# Case 3: negatives
		CASE_NAME="negative"
		INPUT="-3
		-106"
		EXPECTED_OUTPUT="Enter a number: Enter a number: Sum: -109"
		run_and_check "$CASE_NAME" "$INPUT" "$EXPECTED_OUTPUT"
		
		
		
	\end{minted}
\end{frame}









%\begin{frame}{Before DevOps}
%	Software engineering 30 years ago:
%	\begin{itemize}
%		\item Developers write code then pass it to the test team
%		\item Testers make sure it works then pass it to the deployment team
%		\item A different team owns metrics and alerting for live code
%		\item What are some possible problems with this approach?
%	\end{itemize}
%\end{frame}

%\begin{frame}{DevOps Paradigm}
%	Software engineering now:
%	\begin{itemize}
%		\item You own your product end-to-end
%		\item Development, testing, deployment, monitoring, etc
%		\item What new problems might arise? How might we address them?
%	\end{itemize}
%\end{frame}

%\begin{frame}{DevOps and Automation}
%	\begin{itemize}
%		\item Many different hats for the same person
%		\item We now have tooling to automate much of it
%		\item Dedicated engineers to make sure the tools fit together
%	\end{itemize}
%	\includegraphics[width=0.6\columnwidth]{images/Devops1}
%\end{frame}















