\Section{Assembly Globals}

\begin{frame}{Coding in Assembly}

	You'll be doing coding exercises on an online emulator, as well as on your Raspberry Pi

\end{frame}

\Subsection{Why study assembly?}

\begin{frame}[fragile]{Hello World in C}
	\begin{minted}{C}
		#include <stdio.h>

		int main() {
			printf("Hello world!\n");
			return 0;
		}
	\end{minted}

	Your local C compiler can turn this into an executable, which you can then run:

	\begin{minted}{bash}
		$ gcc hello.c
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Hello World in Python}
	\begin{minted}{python}
		print('Hello world!')
	\end{minted}

	You can run this using your local Python interpreter:
	\begin{minted}{bash}
		$ python3 hello.py
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Hello World in Assembly}
	% haven't yet found a perfect highlighter match
	% tasm - dislikes pound signs for int literals
	% nasm, gas - dislikes comments with @
	% ca65 - comments and a lot of commands all black
	% llvm, dasm16, hsail - nope
	% hsail
	\begin{minted}{tasm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			ret
	\end{minted}

	You can assemble this into an executable and run it on your Raspberry Pi:
	\begin{minted}{bash}
		$ gcc hello.s
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item It takes a lot of lines to do anything
		\item There is so much boilerplates
		\item Yikes
	\end{itemize}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item Every computer architecture is a little bit different. An Intel CPU and an AMD CPU can both run the same logic, but they will do things in slightly different ways.
		\item When coding in C, you (mostly) don't have to worry about it. The compiler figures out how to make your logic work on the current hardware.
		\item Same for Python. The interpreter (written in C and compiled) figures out how to make your logic work on the current hardware.
		\item Assembly is not like that. Intel assembly is tied to the hardware specifics of the Intel CPU. ARM assembly is a different language.
		\item We study assembly because we want to talk about what is happening on hardware.
	\end{itemize}

	%	The following command compiles a program in C:
	%	\begin{minted}{bash}
	%		gcc hello.c -o hello
	%	\end{minted}
	%	This creates several intermediate files, eventually creating an executable file (which we can run).
	%	`hello.c' -> preprocessor -> `hello.i' -> compiler -> `hello.s' -> assembler -> `hello.o' -> linker -> `hello'

\end{frame}

% per wikipedia:
% Each computer architecture has its own machine language. Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.


\Subsection{Registers and Memory}

\begin{frame}{Registers and Memory}
	\includegraphics[width=0.7\columnwidth]{images/pi-part-labels}
\end{frame}

\begin{frame}{Registers and Memory}
We'll dig deeper into the hardware later. For now, let's just look at three new terms:
	\begin{itemize}
		\item The \textbf{CPU} is where computations actually happen.
		\item The CPU includes tiny bits of storage for the values it's using right now. These are called \textbf{registers}.
		\item All other data is stored in \textbf{memory} (aka RAM). This includes data as well as the program instructions themselves.
		\item When coding in C or Python, you do not need to worry about registers. You declare variables and the computer figures it out.
		\item When coding in Assembly, we manually move data back and forth between memory and registers.
	\end{itemize}
\end{frame}

\Subsection{Global Constants}

\begin{frame}{Global Constants}
	\begin{itemize}
		\item A global constant is defined in the code
		\item Its value does not change during runtime
		\item It has a name
		\item We can use the name to load the \textbf{address} of that value
	\end{itemize}
\end{frame}

\Subsection{Printf}

\begin{frame}[fragile]{Printf in C}
	\begin{itemize}
		\item We use \texttt{printf} to print output to the terminal in assembly
		\item Let's look at C first. The functionality is the same and C is more legible
	\end{itemize}

	\begin{minted}{C}
		const char* name = "charles";
		printf("hello my name is %s\n", name);
	\end{minted}

	\begin{minted}{C}
	const int year = 2026;
	printf("the current year is %d\n", year);
	\end{minted}
\end{frame}


\begin{frame}{Format Specifiers}
	\begin{itemize}
		\item \texttt{\%d} - interpret the value as an integer
		\item \texttt{\%c} - interpret the value as a character
		\item \texttt{\%s} - interpret the value as a pointer to a null-terminated string
		\item Values are just ones and zeroes! You can use whatever format specifier you want. But you might not like the results
		\item Why do we use a pointer to the string instead of the string itself?
		      % because it might not fit in the register
	\end{itemize}
\end{frame}

% more about format specifiers: https://www.geeksforgeeks.org/c/format-specifiers-in-c/

\begin{frame}[fragile]{Printf in Assembly}

	\begin{minted}{tasm}
		.section .rodata
			output: .ascii "hello my name is %s\n\0"
			name: .ascii "charles"

		.section .text
		.global main
		main:
			ldr x0, =output
			ldr x1, =name
			bl printf
			mov x0, 0
			ret
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Printf in Assembly}
	\begin{minted}{tasm}
		.section .rodata
			output_str: .ascii "the current year is %d\n\0"
			current_year: .word 2026
		
		.section .text
		.global main
		main:
			ldr x0, =output_str
			ldr x1, =current_year
			ldr x1, [x1]
			bl printf
			mov x0, 0
			ret
	\end{minted}
\end{frame}



\begin{frame}[fragile]{Printf in Assembly}
	\begin{minted}{tasm}
		.section .rodata
			output: .ascii "who has %d thumbs and wrote this? %s\n\0"
			name: .ascii "charles\0"
			n_thumbs: .word 2
		
		.section .text
		.global main
		main:
			ldr x0, =output
			ldr x3, =n_thumbs
			ldr x3, [x1]
			ldr x2, =name
			bl printf
			mov x0, 0
			ret
	\end{minted}
\end{frame}


\begin{frame}{Calling Printf}
	We'll get deeper into function calls later. For now:
	\begin{itemize}
		\item \Arm{printf} is a function
		\item \Arm{bl printf} is how we call it
		\item \Arm{printf} looks at \Arm{r0} for its first argument (the output string)
		\item if the output string includes a format identifier, it grabs the value from \Arm{r1}
		\item if the output string includes another formst identifier, it grabs the value from \Arm{r2}, etc
	\end{itemize}
\end{frame}

\begin{frame}{Loading Values from Memory}
	\begin{itemize}
		\item The above code also used the command \Arm{ldr}. This command loads value from memory in two ways
		\item \Arm{ldr r3, =n_thumbs} loads the address of global variable \Arm{n_thumbs} into \Arm{r3}
		\item \Arm{ldr r1, [r3]} goes to the address at \Arm{r3} and puts the value in \Arm{r1}
		\item It is very easy to mix this up!
	\end{itemize}
\end{frame}


\begin{frame}{Favorite Number}
	\begin{itemize}
		\item Strings are passed
		\item The difference is, we now have a global constant number as well as the string
		\item Strings are passed into \texttt{printf} by address. Numbers are passed in by value
	\end{itemize}
\end{frame}








\Subsection{Global Variables}

\Subsection{Scanf}





\begin{frame}[fragile]{Hello World in Assembly (again)}
	\begin{minted}{tasm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			ret
	\end{minted}

	Let's walk through what's happening on each line
\end{frame}





\begin{frame}[fragile]{Hello World in Assembly}
	\begin{alltt}
		\Highlight{@ global read-only data (aka constants)}
		.section .rodata
		greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0"

		\Highlight{@ execution starts here}
		.section .text
		.global main
		main:
		\Highlight{@ load the string address to r0}
		ldr r0, =greeting
		\Highlight{@ print the string from r0}
		bl printf
		\Highlight{@ return 0 (normal exit status)}
		mov r0, \#0
		bl exit
	\end{alltt}
\end{frame}



\begin{frame}{Hello World in Assembly}

	{\Huge
		TODO: don't worry about PC yet? they haven't done the von neumann arch section yet}

\end{frame}



\begin{frame}{Hello World with Instruction Addresses}
	\begin{alltt}
		\begin{tabular}{ r | l }
			-      & \Highlight{@ global read-only data (aka constants)}               \\
			-      & .section .rodata                                                  \\
			-      & greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0" \\
			-      & \Highlight{@ execution starts here}                               \\
			-      & .section .text                                                    \\
			-      & .global main                                                      \\
			-      & main:                                                             \\
			-      & \quad \Highlight{@ load the string address to r0}                 \\
			0x4fe0 & \quad ldr r0, =greeting                                           \\
			-      & \quad \Highlight{@ print the string from r0}                      \\
			0x4fe4 & \quad bl printf                                                   \\
			-      & \quad \Highlight{@ return 0 (normal exit status)}                 \\
			0x4fe8 & \quad mov r0, \#0                                                 \\
			0x4fec & \quad bl exit                                                     \\
		\end{tabular}
	\end{alltt}
\end{frame}

\begin{frame}{Hello World Walkthrough (0)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & ?      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe0 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	The operating system loads instructions and global constants into memory. The program counter \texttt{pc} points to the start of execution.

\end{frame}

\begin{frame}{Hello World Walkthrough (1)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe4 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{ldr} to load the address of global constant \texttt{greeting} to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction

\end{frame}

\begin{frame}{Hello World Walkthrough (2)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe8 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in function \texttt{printf}, which looks at the address from \texttt{r0} and prints the data as a null-terminated string

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (3)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fec &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Move the value zero to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (4)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &   & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ? &                            & 0x4fe4 & bl printf         \\
			r2                            & ? &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ? &                            & 0x4fec & bl exit           \\
			r4                            & ? &                            & 0x4ff0 & Hell              \\
			sp                            & ? &                            & 0x4ff4 & o Wo              \\
			fp                            & ? &                            & 0x4ff8 & rld!              \\
			pc                            & ? &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ? &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in \texttt{exit} function, which exits from the program. The value in \texttt{r0} is the returncode.

	The value of \texttt{pc} is restored for the upstream caller (we'll worry more about this in later chapters)

\end{frame}




\Subsection{Assembly Commands}

\begin{frame}{commands in assembly}

	leave local variable handling for later. str, ldr with brackets

	\begin{itemize}
		\item add rd, rn, \# ... add rd, rn1, rn2
		\item sub rd, rn, \# ... sub rd, rn1, rn2
		\item mov rd, rn ... mov rd, \#
		\item mul rd, rn1, rn2
		\item ldr rd, =label
		\item ldr, rd, [rn]
		\item ldr, rd, [rn, \#]
		\item str rs, rn
	\end{itemize}

\end{frame}




\Subsection{Memory Diagrams}


\Subsection{Automated Testing}






