\Section{Assembly Globals}

\begin{frame}{Coding in Assembly}

	You'll be doing coding exercises on an online emulator, as well as on your Raspberry Pi

\end{frame}

\Subsection{Why study assembly?}

\begin{frame}[fragile]{Hello World in C}
	\begin{minted}{C}
		#include <stdio.h>

		int main() {
			printf("Hello world!\n");
			return 0;
		}
	\end{minted}

	Your local C compiler can turn this into an executable, which you can then run:

	\begin{minted}{bash}
		$ gcc hello.c
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Hello World in Python}
	\begin{minted}{python}
		print('Hello world!')
	\end{minted}

	You can run this using your local Python interpreter:
	\begin{minted}{bash}
		$ python3 hello.py
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Hello World in Assembly}
	% haven't yet found a perfect highlighter match
	% tasm - dislikes pound signs for int literals
	% nasm, gas - dislikes comments with @
	% ca65 - comments and a lot of commands all black
	% llvm, dasm16, hsail - nope
	% hsail
	\begin{minted}{tasm}
		.section .rodata
		greeting: .ascii "Hello world!\n\0"

		.section .text
		.global _start
		_start:
		ldr r0, =greeting
		bl printf
		mov r0, #0
		bl exit
	\end{minted}

	You can assemble this into an executable and run it on your Raspberry Pi:
	\begin{minted}{bash}
		$ gcc hello.s
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item It takes a lot of lines to do anything
		\item There is so much boilerplates
		\item Yikes
	\end{itemize}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item Every computer architecture is a little bit different. An Intel CPU and an AMD CPU can both run the same logic, but they will do things in slightly different ways.
		\item When coding in C, you (mostly) don't have to worry about it. The compiler figures out how to make your logic work on the current hardware.
		\item Same for Python. The interpreter (written in C and compiled) figures out how to make your logic work on the current hardware.
		\item Assembly is not like that. Intel assembly is tied to the hardware specifics of the Intel CPU. ARM assembly is a different language.
		\item We study assembly because we want to talk about what is happening on hardware.
	\end{itemize}

	%	The following command compiles a program in C:
	%	\begin{minted}{bash}
	%		gcc hello.c -o hello
	%	\end{minted}
	%	This creates several intermediate files, eventually creating an executable file (which we can run).
	%	`hello.c' -> preprocessor -> `hello.i' -> compiler -> `hello.s' -> assembler -> `hello.o' -> linker -> `hello'

\end{frame}

% per wikipedia:
% Each computer architecture has its own machine language. Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.

\Subsection{Global Constants}

\begin{frame}{Global Constants}
	\begin{itemize}
		\item A global constant is defined in the code
		\item Its value does not change during runtime
		\item It has a name
		\item We can use the name to load the \textbf{address} of that value
	\end{itemize}
\end{frame}

\Subsection{Printf}


\begin{frame}[fragile]{Favorite Number}
	\begin{minted}{tasm}
		.section .rodata
		output_str: .ascii "My favorite number is %d\n\0"
		favorite_num: .word 123
		
		.section .text
		.global main
		main:
		ldr r0, =output_str
		ldr r1, =favorite_num
		ldr r1, [r1]
		bl printf
		mov r0, #0
		b exit
	\end{minted}
\end{frame}











\Subsection{Global Variables}

\Subsection{Scanf}






\begin{frame}{Registers and Memory}
	\includegraphics[width=0.7\columnwidth]{images/pi-part-labels}
\end{frame}

\begin{frame}{Registers and Memory}
	\begin{itemize}
		\item The \emph{CPU} is where computations actually happen.
		\item The CPU includes tiny bits of storage for the values it's using right now. These are called \emph{registers}.
		\item All other data is stored in \emph{memory} (aka RAM). This includes data as well as the program instructions themselves.
		\item When coding in C or Python, you do not need to worry about registers. You declare variables and the computer figures it out.
		\item When coding in Assembly, we manually move data back and forth between memory and registers.
	\end{itemize}
\end{frame}

\begin{frame}{Registers and Memory}
	Memory stores data and program instructions
	CPU does the work
	Registers are tiny tiny bits of storage right next to the CPU

	Memory is your bookshelf
	Desk is registers
	You are the CPU
	If you want to read or write anything, you have to take the book from your shelf and put it on the desk.


	In C and Python, you don't worry about registers. You declare variables in memory and the compiler figures out how and when to do appropriate reads and writes
	In Assembly, you have to manually shuffle values back and forth between memory and the registers

\end{frame}



\begin{frame}[fragile]{Hello World in Assembly (again)}
	\begin{minted}{tasm}
		.section .rodata
		greeting: .ascii "Hello world!\n\0"

		.section .text
		.global _start
		_start:
		ldr r0, =greeting
		bl printf
		mov r0, #0
		bl exit
	\end{minted}

	Let's walk through what's happening on each line
\end{frame}





\begin{frame}[fragile]{Hello World in Assembly}
	\begin{alltt}
		\Highlight{@ global read-only data (aka constants)}
		.section .rodata
		greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0"

		\Highlight{@ execution starts here}
		.section .text
		.global main
		main:
		\Highlight{@ load the string address to r0}
		ldr r0, =greeting
		\Highlight{@ print the string from r0}
		bl printf
		\Highlight{@ return 0 (normal exit status)}
		mov r0, \#0
		bl exit
	\end{alltt}
\end{frame}



\begin{frame}{Hello World in Assembly}

	{\Huge
		TODO: don't worry about PC yet? they haven't done the von neumann arch section yet}

\end{frame}



\begin{frame}{Hello World with Instruction Addresses}
	\begin{alltt}
		\begin{tabular}{ r | l }
			-      & \Highlight{@ global read-only data (aka constants)}               \\
			-      & .section .rodata                                                  \\
			-      & greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0" \\
			-      & \Highlight{@ execution starts here}                               \\
			-      & .section .text                                                    \\
			-      & .global main                                                      \\
			-      & main:                                                             \\
			-      & \quad \Highlight{@ load the string address to r0}                 \\
			0x4fe0 & \quad ldr r0, =greeting                                           \\
			-      & \quad \Highlight{@ print the string from r0}                      \\
			0x4fe4 & \quad bl printf                                                   \\
			-      & \quad \Highlight{@ return 0 (normal exit status)}                 \\
			0x4fe8 & \quad mov r0, \#0                                                 \\
			0x4fec & \quad bl exit                                                     \\
		\end{tabular}
	\end{alltt}
\end{frame}

\begin{frame}{Hello World Walkthrough (0)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & ?      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe0 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	The operating system loads instructions and global constants into memory. The program counter \texttt{pc} points to the start of execution.

\end{frame}

\begin{frame}{Hello World Walkthrough (1)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe4 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{ldr} to load the address of global constant \texttt{greeting} to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction

\end{frame}

\begin{frame}{Hello World Walkthrough (2)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe8 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in function \texttt{printf}, which looks at the address from \texttt{r0} and prints the data as a null-terminated string

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (3)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & bl exit           \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fec &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Move the value zero to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (4)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &   & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ? &                            & 0x4fe4 & bl printf         \\
			r2                            & ? &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ? &                            & 0x4fec & bl exit           \\
			r4                            & ? &                            & 0x4ff0 & Hell              \\
			sp                            & ? &                            & 0x4ff4 & o Wo              \\
			fp                            & ? &                            & 0x4ff8 & rld!              \\
			pc                            & ? &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ? &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in \texttt{exit} function, which exits from the program. The value in \texttt{r0} is the returncode.

	The value of \texttt{pc} is restored for the upstream caller (we'll worry more about this in later chapters)

\end{frame}




\Subsection{Assembly Commands}

\begin{frame}{commands in assembly}

	leave local variable handling for later. str, ldr with brackets

	\begin{itemize}
		\item add rd, rn, \# ... add rd, rn1, rn2
		\item sub rd, rn, \# ... sub rd, rn1, rn2
		\item mov rd, rn ... mov rd, \#
		\item mul rd, rn1, rn2
		\item ldr rd, =label
		\item ldr, rd, [rn]
		\item ldr, rd, [rn, \#]
		\item str rs, rn
	\end{itemize}

\end{frame}




\Subsection{Memory Diagrams}


\Subsection{Automated Testing}






