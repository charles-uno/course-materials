\Section{Assembly Functions}


\Subsection{The Stack}

\begin{frame}{Push and Pop}

	When a program starts running, the OS loads the instructions into memory.

	It also allocates memory for the program to use during execution

	There is a special register called the stack pointer which provides the location of that memory

\end{frame}


\begin{frame}{Working Memory}
	\begin{columns}
		\begin{column}{0.5\textwidth}

			we do not know what piece of memory the OS will provide

			arbitrarily say it starts at 0x5000

			stack pointer points to the "bottom" of our available memory. we work our way "up" by subtracting from the stack pointer

			The rules are the same when we call a function. It looks at SP to know the "bottom" of its available memory, then works up from there

		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{ r | l }
					0x4ff8 & \vdots           \\
					0x4ffc & available        \\
					0x5000 & available        \\
					0x5004 & in use by parent \\
					0x5008 & in use by parent \\
					0x500c & \vdots           \\
				\end{tabular}
			\end{alltt}
		\end{column}
	\end{columns}

\end{frame}


\Subsection{Calling a Function}


\begin{frame}{Branch and Link}

	New command: BL

	Branch and Link

	Branch = modify PC. Recall: PC tells us what to do next. Usually we just do the next line. In this case, we will jump to some other part of the program. This is how we call a function.

	Link = set LR to the PC of the next line. Once we're done with the function, this is how we return to the parent context.

\end{frame}

\Subsection{Stack Frames}


\begin{frame}{Frame Pointer}

	\begin{itemize}
		\item Not strictly necessary
		\item Code is easier to read
		\item Integration with debugging tools
		\item Stack pointer can move during the function
		\item Skipping the frame pointer can be skipped by some compilers
	\end{itemize}

	% https://stackoverflow.com/questions/46797915/what-are-the-advantages-of-a-frame-pointer

\end{frame}


\begin{frame}{SIMD}

	\begin{itemize}
		\item SIMD - single instruction, multiple data
		\item 64 bit architecture (8 bytes)
		\item there are cases where it works in chunks of 16 bytes
		\item I don't have time to worry about that, and neither do you. For the purposes of this class, everything is 16 bytes.
		\item This is wasteful! We are using double the memory we need, sometimes more
		\item That's ok. We are not trying to become assembly developers. We are getting exposure to important concepts
	\end{itemize}

\end{frame}



\begin{frame}{Stack Frame Walkthrough}
	\small
	\begin{columns}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{r | l}
					       & {\quad}.section .rodata \\
					       &                         \\
					       & {\quad}.text            \\
					       & func:                   \\
					0x3fd4 & {\quad}push \{fp, lr\}  \\
					0x3fd8 & {\quad}add fp, sp, \#4  \\
					0x3fdc & {\quad}sub sp, sp, \#4  \\
					0x3fe0 & {\quad}@ ...            \\
					0x3fe4 & {\quad}sub sp, fp, \#4  \\
					0x3fe8 & {\quad}pop \{fp, pc\}   \\
					       &                         \\
					       & {\quad}.global main     \\
					       & main:                   \\
					0x3fec & {\quad}push \{fp, lr\}  \\
					0x3ff0 & {\quad}add fp, sp, \#4  \\
					0x3ff4 & {\quad}sub sp, sp, \#8  \\
					0x3ff8 & {\quad}bl func          \\
					0x3ffc & {\quad}sub sp, fp, \#4  \\
					0x4000 & {\quad}pop \{fp, pc\}   \\
				\end{tabular}
			\end{alltt}
		\end{column}
		\begin{column}{0.5\textwidth}
			\begin{alltt}
				\begin{tabular}{ r | l}
					\vdots & \vdots    \\
					0x4ffc & available \\
					0x5000 & available \\
					0x5004 & in use    \\
					\vdots & \vdots    \\
				\end{tabular}
			\end{alltt}

			\vspace{1cm}

			\begin{alltt}
				\begin{tabular}{ r | l}
					sp & 0x5004    \\
					fp & parent fp \\
					pc & 0x3fec    \\
					lr & parent lr \\
				\end{tabular}
			\end{alltt}
		\end{column}
	\end{columns}

\end{frame}

\Subsection{Local Variables}


\begin{frame}{Local Variables}
	\begin{itemize}
		\item LDR from an address
		\item STR to an address
		\item Offsets from SP and FP
	\end{itemize}
\end{frame}








\begin{frame}{Hello World in Assembly}

	{\Huge
		TODO: don't worry about PC yet? they haven't done the von neumann arch section yet}

\end{frame}



\begin{frame}{Hello World with Instruction Addresses}
	\begin{alltt}
		\begin{tabular}{ r | l }
			-      & \Highlight{@ global read-only data (aka constants)}               \\
			-      & .section .rodata                                                  \\
			-      & greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0" \\
			-      & \Highlight{@ execution starts here}                               \\
			-      & .section .text                                                    \\
			-      & .global main                                                      \\
			-      & main:                                                             \\
			-      & \quad \Highlight{@ load the string address to r0}                 \\
			0x4fe0 & \quad ldr r0, =greeting                                           \\
			-      & \quad \Highlight{@ print the string from r0}                      \\
			0x4fe4 & \quad bl printf                                                   \\
			-      & \quad \Highlight{@ return 0 (normal exit status)}                 \\
			0x4fe8 & \quad mov r0, \#0                                                 \\
			0x4fec & \quad b exit                                                      \\
		\end{tabular}
	\end{alltt}
\end{frame}

\begin{frame}{Hello World Walkthrough (0)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & ?      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe0 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	The operating system loads instructions and global constants into memory. The program counter \texttt{pc} points to the start of execution.

\end{frame}

\begin{frame}{Hello World Walkthrough (1)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe4 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{ldr} to load the address of global constant \texttt{greeting} to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction

\end{frame}

\begin{frame}{Hello World Walkthrough (2)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe8 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in function \texttt{printf}, which looks at the address from \texttt{r0} and prints the data as a null-terminated string

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (3)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fec &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Move the value zero to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (4)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &   & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ? &                            & 0x4fe4 & bl printf         \\
			r2                            & ? &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ? &                            & 0x4fec & b exit            \\
			r4                            & ? &                            & 0x4ff0 & Hell              \\
			sp                            & ? &                            & 0x4ff4 & o Wo              \\
			fp                            & ? &                            & 0x4ff8 & rld!              \\
			pc                            & ? &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ? &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in \texttt{exit} function, which exits from the program. The value in \texttt{r0} is the returncode.

	The value of \texttt{pc} is restored for the upstream caller (we'll worry more about this in later chapters)

\end{frame}

