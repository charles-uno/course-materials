
\Section{Instructions on Hardware}

\begin{frame}{Von Neumann Architecture}
	\begin{itemize}
		\item What are the fundamental parts of a computer?
		\item How do they work together to execute instructions?
	\end{itemize}
	\includegraphics[width=\columnwidth]{images/von-neumann-architecture.png}
\end{frame}

\Subsection{Hardware Components}

\begin{frame}{What's Where?}
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{images/pi-part-labels}
	\end{center}
\end{frame}


\begin{frame}{CPU}

	\begin{itemize}
		\item Processing unit that executes instructions
	\end{itemize}

	Processing unit executes program instructions. Registers for storing the very specific pieces of data you're currently using. ALU which does the actual math. For example, if you're adding two numbers. Load into r0 and r1. Send them through the ALU. Store the result in r2.

	Control unit drives execution. IR: instruction register. Holds the instruction currently being executed. PC: program counter. Holds the address of the next instruction.


	Implements the processing unit and control unit of the von Neumann architecture
	Functional units:
	The arithmetic logic unit (ALU) performs arithmetic and logic operations
	General purpose registers for storing program data
	Control circuitry and special purpose registers for instruction execution
	The clock drives the circuitry of the CPU to execute program instructions
\end{frame}


\begin{frame}{CPU}

	It's all boolean logic!

	\includegraphics[width=\columnwidth]{images/example-alu}
	\includegraphics[width=\columnwidth]{images/register-file}
	\includegraphics[width=\columnwidth]{images/full-cpu}

\end{frame}


\begin{frame}{Main Memory}
	Stores program data and instructions

	historically: tiny bits of magnetic field on a spinning disk

	modern SSD: basically a bunch of NAND gates plugged into each other

	https://en.wikipedia.org/wiki/Flash_memory#NAND_flash
\end{frame}


\begin{frame}{Busses}
	\begin{itemize}
		\item Address bus: what address in memory are we working with?
		\item Control bus: what are we doing with that address? Eg read or write
		\item Data bus: carries data between registers and memory
	\end{itemize}
\end{frame}


\begin{frame}{Input and Output}

	The input unit(s) load program data and instructions on the computer and initiate program execution.

	The output unit(s) store or receive program results.

\end{frame}

\Subsection{Executing an Instruction}

\begin{frame}{Execution Steps}
	There are four steps to executing an instruction:
	\begin{itemize}
		\item Fetch
		\item Decode
		\item Execute
		\item Write
	\end{itemize}
\end{frame}

\begin{frame}{Fetch}
	\includegraphics[width=\columnwidth]{images/fdew-add-fetch}
	\begin{itemize}
		\item Special register PC holds the address of the instruction
		\item Read instruction from memory, store to IR
		\item Increment PC to point to the next instruction
	\end{itemize}
\end{frame}

\begin{frame}{Decode}
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{images/fdew-add-decode}
	\end{center}
	\begin{itemize}
		\item The CPU breaks down the instruction bits from IR into its component parts
		\item Opcode is sent to the ALU, arguments to the registers
		\item Basically a bunch of multiplexers
	\end{itemize}
\end{frame}

\begin{frame}{Walkthrough: Execute}
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{images/fdew-add-execute}
	\end{center}
	\begin{itemize}
		\item ALU performs the operation on the operands
		\item ALU outputs result and condition code values associated with the result value.
	\end{itemize}
\end{frame}

\begin{frame}{Walkthrough: Write(back)}
	\begin{center}
		\includegraphics[width=0.7\columnwidth]{images/fdew-add-write}
	\end{center}
	\begin{itemize}
		\item Result from ALU is stored in destination register
	\end{itemize}
\end{frame}

\begin{frame}{Von Neumann Bottleneck}
	\begin{itemize}
		\item Suppose you have an array of a billion integers in memory. You want to add 1 to each of them. How do you do it?
	\end{itemize}
\end{frame}


\begin{frame}{Von Neumann Bottleneck}
	\begin{itemize}
		\item Suppose you have an array of a billion integers in memory. You want to add 1 to each of them. How do you do it?
		\item You have to load each value from memory, store it in a register, run it through the CPU, and write it back to memory
		\item This is a lot of work!
	\end{itemize}
\end{frame}

\Subsection{Clock-Driven Execution}

\begin{frame}{Clock-Driven Execution}
	\begin{itemize}
		\item Electrical signals move within the CPU, between CPU and memory, etc
		\item Different paths, different lengths, different amounts of time for signals to get where they're going
		\item How do we keep everything coordinated?
	\end{itemize}
\end{frame}

\begin{frame}{What does a clock mean?}
	\begin{itemize}
		\item The CPU has a clock
		\item Clock signal flips true/false at a very consistent rate
		\item Execution advances one step every tick of the clock
		\item System status in between ticks does not matter
		\item Physical mechanism: quartz. Electricity causes consistent predictable vibration
	\end{itemize}
\end{frame}

\begin{frame}{Clock Speed}
	\begin{itemize}
		\item 1 Hz (Hertz) = 1 cycle per second
		\item 1 kHz = 1,000 Hz = 1,000 cycles per second
		\item 1 MHz = 1,000,000 Hz = 1,000,000 cycles per second
		\item 1 GHz = 1,000,000 Hz = 1,000,000,000 cycles per second
		\item $10^9$ cycles per second means each cycle lasts $\frac{1}{10^9}$ seconds
	\end{itemize}
\end{frame}

\begin{frame}{Why not just make the clock run faster?}
	\begin{itemize}
		\item Electricity moves at approximately the speed of light
		\item Speed of light is about one foot per nanosecond
		\item If the computer runs at 1 GHz, that's one cycle every nanosecond
		\item Wires in the CPU are twisted and packed very tightly. How long do you suppose they would be if straightened?
	\end{itemize}
\end{frame}

\Subsection{Memory Hierarchy}

\begin{frame}{Size vs Speed}
	\begin{itemize}
		\item How many books can you have in your hands at a time?
		\item How many books can you store on your bookshelf?
		\item How many books are there in the library?
		\item For each case, how accessible are those books?
	\end{itemize}
\end{frame}

\begin{frame}{Book Storage Hierarchy}
	\includegraphics[width=\columnwidth]{images/memory-hierarchy-books.png}
\end{frame}

\begin{frame}{Books and Bytes}
	\begin{itemize}
		\item Data works the same way
		\item Registers are super close to the CPU, but can only hold a few bytes of data
		\item Memory holds more, but you have to load it before you can use it
		\item Remote storage is even bigger and even slower
	\end{itemize}
\end{frame}

\begin{frame}{Data Storage Hierarchy}
	\includegraphics[width=\columnwidth]{images/memory-hierarchy.png}
\end{frame}

\begin{frame}{Primary Storage}
	\begin{itemize}
		\item Primary storage can be accessed directly by the CPU
		\item Registers, cache, main memory
		\item Physical mechanism: SRAM (static RAM). Data is stored in electric circuits, such as latches. Fastest type of storage. Used for registers
		\item Another physical mechanism: DRAM (dynamic RAM). Data is stored in capacitors holding electric charge. Slower, cheaper, denser. Used for main memory
	\end{itemize}
\end{frame}

\begin{frame}{Secondary Storage}
	\begin{itemize}
		\item Secondary storage must be copied into primary storage before it can be accessed
		\item HDD (hard disk drives). Magnetic storage on a spinning circular platter. Read/write arm hovers just a few atoms away from the disk surface. Moving pieces. Ask your parents if you want to make them feel old.
		\item SSD (solid state drives). No moving parts. Thousands of transistors chained together.
		\item Remote storage. Physical mechanism doesn't matter much since latency and transfer rate are due to the network
	\end{itemize}
\end{frame}

\begin{frame}{Quantifying Storage}
	\begin{itemize}
		\item Latency: how long to get data (measured in nanoseconds)
		\item Capacity: how much data (measured in bytes)
		\item Transfer rate (aka throughput): how fast we can read or write (measured in bytes/second)
	\end{itemize}
\end{frame}

\Subsection{Locality \& Cache}

\begin{frame}{Wait -- what's a cache?}
	\begin{itemize}
		\item Cache is in between registers and main memory (in every way)
		\item Physically closer to the ALU than memory, but not as close as the registers
		\item Stores more data than the registers, but not as much as memory
		\item Why might this be useful?
	\end{itemize}
\end{frame}

\begin{frame}{Temporal Locality}
	\begin{itemize}
		\item When you load a value from memory, there's a decent chance you'll use that same value again soon
		\item The computer stores that value in the cache
		\item When you try to load the value next time, the cache intercepts your request and returns the data much faster
		\item This is called temporal locality (similar in time)
	\end{itemize}
\end{frame}

\begin{frame}{Spatial Locality}
	\begin{itemize}
		\item When you load one value from an array, there's a decent chance you'll be back for the rest soon
		\item The computer stores "nearby" data in the cache
		\item When you try to load that data from memory, the cache intercepts your request and returns the data much faster
		\item This is called spatial locality (similar in space)
	\end{itemize}
\end{frame}

\begin{frame}{Hits and Misses}
	\begin{itemize}
		\item Cache hit: you try to load data from memory. It's already in the cache! You get your data faster that you expected
		\item Cache miss: you try to load data from memory. It's not in the cache. You have to wait for the data to be loaded from memory (about 10x slower)
	\end{itemize}
\end{frame}

\begin{frame}{Cache Eviction}
	\begin{itemize}
		\item Caches hold only a small amount of data compared to memory
		\item If the computer wants to store something in the cache, but the cache is full, existing data has to be deleted to make room
		\item This is called a cache eviction
	\end{itemize}
\end{frame}

\begin{frame}{Caching Applications}
	\begin{itemize}
		\item The cache is a hardware component in between the CPU and main memory
		\item Caches can also be implemented in software!
		\item For example: your browser caches images from websites you visit. If you visit the same site later, the browser can find the image locally. This is much faster than pulling it across the network
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Caching in Software}
	You can even use the idea of a cache within your code!

	What happens here if you call \mintedinline{python}{fibonacci(1000)}?
	\begin{minted}{python}
def fibonacci(n):
	if n < 2:
		return n
	return fibonacci(n-1) + fibonacci(n-2)
\end{minted}

\end{frame}


\begin{frame}[fragile]{Caching in Software}
	How about now?
	\begin{minted}{python}
CACHE = {}

def fibonacci(n):
	if n not in CACHE:
		if n < 2:
			CACHE[n] = n
		else:
			CACHE[n] = fibonacci(n-1) + fibonacci(n-2)
	return CACHE[n]
\end{minted}

\end{frame}


\Subsection{Pipelining and Hazards}

\begin{frame}{Remember Execution Steps}
	\begin{itemize}
		\item Fetch
		\item Decode
		\item Execute
		\item Write
	\end{itemize}
	Which of these stages do actual work? Which are overhead?
\end{frame}

\begin{frame}{Time is Money}
	\includegraphics[width=\columnwidth]{images/fdew-before-pipelining}
	\begin{itemize}
		\item The execute step is the only step that uses the CPU. The rest are just moving values around
		\item That means the CPU is sitting idle 75\% of the time at least!
		\item Is there any way to be more efficient?
	\end{itemize}
\end{frame}

\begin{frame}{Pipelining}
	\begin{itemize}
		\item The execute step is the only step that uses the CPU. The rest are just moving values around
		\item That means the CPU is sitting idle 75\% of the time at least!
		\item Is there any way to be more efficient?
	\end{itemize}
\end{frame}






\begin{frame}{foo bar}
	\includegraphics[width=\columnwidth]{images/instruction-breakdown}
	\begin{itemize}
		\item fizz
		\item buzz
	\end{itemize}
\end{frame}



\begin{frame}{Eager Execution Gone Wrong}
	\includegraphics[width=\columnwidth]{images/xkcd-meltdown-cropped.png}
\end{frame}
