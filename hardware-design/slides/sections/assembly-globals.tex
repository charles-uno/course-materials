\Section{Assembly Globals}

\begin{frame}{Coding in Assembly}
	\begin{itemize}
		\item We'll be doing some coding exercises in Assembly (specifically aarch64) on emulators and on a Raspberry Pi
		\item Assembly code can be super efficient. Ours won't be. That's not why we're here
		\item We are not studying to become assembly developers. We are here for the core concepts
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Hello World in C}
	\begin{minted}{C}
		#include <stdio.h>
		int main() {
			printf("Hello world!\n");
			return 0;
		}
	\end{minted}

	Your local C compiler can turn this into an executable, which you can then run:

	\begin{minted}{bash}
		$ gcc hello.c
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}


\begin{frame}[fragile]{Hello World in Python}
	\begin{minted}{python}
		print('Hello world!')
	\end{minted}

	You can run this using your local Python interpreter:
	\begin{minted}{bash}
		$ python3 hello.py
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Hello World in Assembly}
	% haven't yet found a perfect highlighter match
	% tasm - pretty good, does not like //
	% gas - does not like = for globals
	% nasm - does not like // or =
	% ca65 - comments and a lot of commands all black
	% llvm, dasm16, hsail - nope
	\begin{minted}{tasm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			b exit
	\end{minted}

	You can assemble this into an executable and run it on your Raspberry Pi:
	\begin{minted}{bash}
		$ gcc hello.s
		$ ./a.out
		Hello world!
	\end{minted}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item It takes a lot of lines to do anything
		\item There is so much boilerplates
		\item Yikes
	\end{itemize}
\end{frame}

\begin{frame}{What makes assembly special?}
	\begin{itemize}
		\item An Intel CPU and an AMD CPU can both run the same logic, but they will do things in slightly different ways.
		\item When coding in C, you (mostly) don't have to worry about it. The compiler makes your logic work on the current hardware.
		\item Same for Python. The interpreter (itself compiled) figures it out.
		\item Assembly is not like that. Intel assembly is tied to the hardware specifics of the Intel CPU. ARM assembly is a different language.
		\item We study Assembly because we want to talk about what is happening on hardware.
	\end{itemize}

	%	The following command compiles a program in C:
	%	\begin{minted}{bash}
	%		gcc hello.c -o hello
	%	\end{minted}
	%	This creates several intermediate files, eventually creating an executable file (which we can run).
	%	`hello.c' -> preprocessor -> `hello.i' -> compiler -> `hello.s' -> assembler -> `hello.o' -> linker -> `hello'

\end{frame}

% per wikipedia:
% Each computer architecture has its own machine language. Computers differ in the number and type of operations they support, in the different sizes and numbers of registers, and in the representations of data in storage. While most general-purpose computers are able to carry out essentially the same functionality, the ways they do so differ; the corresponding assembly languages reflect these differences.

%\Subsection{Registers and Memory}

%\begin{frame}{Registers and Memory}
%We'll dig deeper into the hardware later. For now, let's just look at three new terms:
%	\begin{itemize}
%		\item The \textbf{CPU} is where computations actually happen.
%		\item The CPU includes tiny bits of storage for the values it's using right now. These are called \textbf{registers}.
%		\item All other data is stored in \textbf{memory} (aka RAM). This includes data as well as the program instructions themselves.
%		\item When coding in C or Python, you do not need to worry about registers. You declare variables and the computer figures it out.
%		\item When coding in Assembly, we manually move data back and forth between memory and registers.
%	\end{itemize}
%\end{frame}

\Subsection{Assembly Program Structure}

\begin{frame}[fragile]{Assembly Boilerplate}
	The Assembly programs we write in this course will look like this:

	\begin{minted}{tasm}
		.section .rodata
			/* global constants */
		
		.section .data
			// global variables
		
		.section .text
		.global main
		main:
			// execution starts here

			// return 0 (normal exit status)
			mov x0, 0
			b exit
	\end{minted}

You will have plenty of examples to work from. Don't worry about memorizing this right now.

\end{frame}

% caps sensitivity. some things are not caps sensitive, but easier to just work in lowercase

% indentation. you do you


\begin{frame}[fragile]{Global Contants and Variables}

	\begin{minted}{tasm}
		.section .rodata
			// global constants
			name: .ascii "charles\0"
			n_thumbs: .word 2

		.section .data
			// global variables
			num_koalas: .word 0
		
		.section .text
		.global main
		main:
			// execution starts here

			// return 0 (normal exit status)
			mov x0, 0
			b exit
	\end{minted}
\end{frame}






\begin{frame}[fragile]{Assembly Boilerplate}
	The Assembly programs we write in this course will look like this:

	\begin{minted}{tasm}
		.section .rodata
			// global constants
		
		.section .data
			// global variables
		
		// execution starts here
		.section .text
		.global main
		main:
			// execution starts here

			// return 0 (normal exit status)
			mov x0, 0
			b exit
	\end{minted}
\end{frame}












\Subsection{Assembly Commands}

\begin{frame}{Register Names}
	\begin{itemize}
		\item The 64-bit registers in aarch64 are named \Arm{x0}, \Arm{x1}, etc
		\item If you see \Arm{w0}, that's the lower 32 bits of \Arm{x0}
		\item If you see \Arm{r0}, it's probably a typo left over from the previous version of this class
	\end{itemize}
\end{frame}

\begin{frame}{Don't Worry!}
	\begin{itemize}
		\item We are just looking at these to get a feel for them
		\item You will have plenty of time to practice
		\item You do not need to worry about memorizing anything right now
	\end{itemize}
\end{frame}

\begin{frame}{Basic Commands in Assembly}
	\begin{itemize}
		\item \Arm{... // double slash for inline comments}
		\item \Arm{add x0, x1, 5 // add x1 + 5, store in x0}
		\item \Arm{add x0, x1, x7 // add x1 + x7, store in x0}
		\item \Arm{mov x4, 5 // set x4 = 5 (literal number)}
		\item \Arm{mov x4, x5 // set x4 = x5}
		\item \Arm{mul x2, x8, x3 // multiply x8 * x3, store in x2}
		\item \Arm{mul x2, x8, 12 // multiply x8 * 12, store in x2}
		\item \Arm{sub x5, x4, 3 // subtract x4 - 3, store in x5}
		\item \Arm{sub x5, x4, x3 // subtract x4 - x3, store in x5}
	\end{itemize}
\end{frame}


\begin{frame}[fragile]{Reading from Memory}

	Load the \emph{address} of global variable \Arm{fizz} to \Arm{x3}:
	\begin{minted}{tasm}
		ldr x3, =fizz
	\end{minted}

	Register \Arm{x2} holds an \emph{address}. Load the \emph{value} to \Arm{x3}:
	\begin{minted}{tasm}
		ldr x3, [x2]
	\end{minted}

	Register \Arm{x2} holds an \emph{address}. Load the \emph{value} from \Arm{x2-0x20} to \Arm{x3}:
	\begin{minted}{tasm}
		ldr x3, [x2, -0x20]
	\end{minted}

	Global variable \Arm{fizz} holds a number. Load the address, then load the value from that address:
	\begin{minted}{tasm}
		ldr x3, =fizz
		ldr x3, [x3] // yes it can be the same register
	\end{minted}

\end{frame}


\begin{frame}[fragile]{Writing to Memory}

	Register \Arm{x5} holds an \emph{address}. Store the \emph{value} from \Arm{x7} to that address:
	\begin{minted}{tasm}
		str x7, [x5]
	\end{minted}

	\vspace{0.5cm}

	Register \Arm{x5} holds an \emph{address}. Store the \emph{value} from \Arm{x8} to \Arm{x5+0x10}
	\begin{minted}{tasm}
		str x7, [x5, 0x10]
	\end{minted}
\end{frame}

\begin{frame}[fragile]{We'll talk more about these ones later}
	Call the function \Arm{printf}, which prints output to the terminal:
	\begin{minted}{tasm}
		bl printf
	\end{minted}

	\vspace{0.3cm}

	Call the function \Arm{exit}, which exits the program:
	\begin{minted}{tasm}
		b exit
	\end{minted}

	\vspace{0.3cm}

	\Arm{b} is "branch", \Arm{bl} is "branch and link". More on those later

\end{frame}


\Subsection{Printf}

\begin{frame}[fragile]{Printf in C}
	\begin{itemize}
		\item We use \texttt{printf} to print output to the terminal in Assembly
		\item Let's look at C first. The functionality is the same and C is more legible
	\end{itemize}

	\begin{minted}{C}
		const char* name = "charles";
		printf("hello my name is %s\n", name);
	\end{minted}

	\begin{minted}{C}
		const int m = 2, n = 3;
		int s = m + n;
		printf("%d + %d = %d\n", m, n, s);
	\end{minted}
\end{frame}

\begin{frame}{What does it do?}
	\begin{itemize}
		\item The first argument to \texttt{printf} must be a string
		\item The string can include format specifiers like \texttt{\%d}
		\item Subsequent arguments are inserted into the string (in order) in place of the format specifiers
	\end{itemize}
\end{frame}

\begin{frame}{Format Specifiers}
	\begin{itemize}
		\item \texttt{\%d} - interpret the value as an integer
		\item \texttt{\%c} - interpret the value as an ASCII character
		\item \texttt{\%s} - interpret the value as a \emph{pointer} to a null-terminated string
		\item These values are just ones and zeroes! You can use whichever format speficier you want. But you might not like the results
		\item Why do we use a pointer to the string instead of the string itself?
	\end{itemize}
\end{frame}

% more about format specifiers: https://www.geeksforgeeks.org/c/format-specifiers-in-c/

\begin{frame}{Calling Printf in Assembly}
	We'll get deeper into function calls later. For now:
	\begin{itemize}
		\item \Arm{printf} is a function
		\item \Arm{bl printf} is how we call it
		\item \Arm{printf} looks at \Arm{x0} for its first argument (the output string)
		\item if the output string includes a format identifier, it grabs the value from \Arm{x1}
		\item if the output string includes another format identifier, it grabs the value from \Arm{x2}, etc
		\item Format identifiers in Assembly are the same as those in C
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 1}
	\begin{minted}{tasm}
		.section .rodata
			output: .ascii "hello my name is %s\n\0"
			name: .ascii "charles\0"

		.section .text
		.global main
		main:
			ldr x0, =output
			ldr x1, =name
			bl printf
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 2}
	\begin{minted}{tasm}
		.section .rodata
			output_str: .ascii "the current year is %d\n\0"
			current_year: .word 2026
		
		.section .text
		.global main
		main:
			ldr x0, =output_str
			ldr x1, =current_year
			ldr x1, [x1]
			bl printf
			mov x0, 0
			b exit
	\end{minted}
\end{frame}

\begin{frame}[fragile]{Assembly Printf Example 3}
	\begin{minted}{tasm}
	.section .rodata
		output_str: .ascii "%d + %d = %d\n\0"
	
	.section .text
	.global main
	main:
		ldr x0, =output_str
		mov x1, 2
		mov x2, 3
		add x3, x1, x2
		bl printf
		mov x0, 0
		b exit
	\end{minted}
\end{frame}
















\Subsection{Global Constants}

\begin{frame}{Global Constants}
	\begin{itemize}
		\item A global constant is defined in the code
		\item Its value does not change during runtime
		\item It has a name
		\item We can use the name to load the \textbf{address} of that value
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Hello World in Assembly (again)}
	\begin{minted}{tasm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			b exit
	\end{minted}

	\begin{itemize}
		\item \Arm{greeting} is a local variable
		\item We use \arm{ldr} to load the address of \Arm{greeting} into \Arm{x0}
	\end{itemize}
\end{frame}









\Subsection{Global Variables}

\Subsection{Scanf}





\begin{frame}[fragile]{Hello World in Assembly (again)}
	\begin{minted}{tasm}
		.section .rodata
			greeting: .ascii "Hello world!\n\0"

		.section .text
		.global main
		main:
			ldr x0, =greeting
			bl printf
			mov x0, 0
			b exit
	\end{minted}

	Let's walk through what's happening on each line
\end{frame}





\begin{frame}[fragile]{Hello World in Assembly}
	\begin{alltt}
		\Highlight{@ global read-only data (aka constants)}
		.section .rodata
		greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0"

		\Highlight{@ execution starts here}
		.section .text
		.global main
		main:
		\Highlight{@ load the string address to r0}
		ldr r0, =greeting
		\Highlight{@ print the string from r0}
		bl printf
		\Highlight{@ return 0 (normal exit status)}
		mov r0, \#0
		b exit
	\end{alltt}
\end{frame}



\begin{frame}{Hello World in Assembly}

	{\Huge
		TODO: don't worry about PC yet? they haven't done the von neumann arch section yet}

\end{frame}



\begin{frame}{Hello World with Instruction Addresses}
	\begin{alltt}
		\begin{tabular}{ r | l }
			-      & \Highlight{@ global read-only data (aka constants)}               \\
			-      & .section .rodata                                                  \\
			-      & greeting: .ascii "Hello World!{\textbackslash}n{\textbackslash}0" \\
			-      & \Highlight{@ execution starts here}                               \\
			-      & .section .text                                                    \\
			-      & .global main                                                      \\
			-      & main:                                                             \\
			-      & \quad \Highlight{@ load the string address to r0}                 \\
			0x4fe0 & \quad ldr r0, =greeting                                           \\
			-      & \quad \Highlight{@ print the string from r0}                      \\
			0x4fe4 & \quad bl printf                                                   \\
			-      & \quad \Highlight{@ return 0 (normal exit status)}                 \\
			0x4fe8 & \quad mov r0, \#0                                                 \\
			0x4fec & \quad b exit                                                      \\
		\end{tabular}
	\end{alltt}
\end{frame}

\begin{frame}{Hello World Walkthrough (0)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & ?      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe0 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	The operating system loads instructions and global constants into memory. The program counter \texttt{pc} points to the start of execution.

\end{frame}

\begin{frame}{Hello World Walkthrough (1)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe4 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{ldr} to load the address of global constant \texttt{greeting} to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction

\end{frame}

\begin{frame}{Hello World Walkthrough (2)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0x4ff0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fe8 &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in function \texttt{printf}, which looks at the address from \texttt{r0} and prints the data as a null-terminated string

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (3)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &        & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0      &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ?      &                            & 0x4fe4 & bl printf         \\
			r2                            & ?      &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ?      &                            & 0x4fec & b exit            \\
			r4                            & ?      &                            & 0x4ff0 & Hell              \\
			sp                            & ?      &                            & 0x4ff4 & o Wo              \\
			fp                            & ?      &                            & 0x4ff8 & rld!              \\
			pc                            & 0x4fec &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ?      &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Move the value zero to \texttt{r0}

	Also increment \texttt{pc} to point to the next instruction


\end{frame}

\begin{frame}{Hello World Walkthrough (4)}
	\begin{alltt}
		\begin{tabular}{ r | l p{5mm} r | l }
			\multicolumn{2}{c}{Registers} &   & \multicolumn{2}{c}{Memory}                              \\
			r0                            & 0 &                            & 0x4fe0 & ldr r0, =greeting \\
			r1                            & ? &                            & 0x4fe4 & bl printf         \\
			r2                            & ? &                            & 0x4fe8 & mov r0, \#0       \\
			r3                            & ? &                            & 0x4fec & b exit            \\
			r4                            & ? &                            & 0x4ff0 & Hell              \\
			sp                            & ? &                            & 0x4ff4 & o Wo              \\
			fp                            & ? &                            & 0x4ff8 & rld!              \\
			pc                            & ? &                            & 0x4ffc & {\textbackslash}0 \\
			lr                            & ? &                            & 0x5000 & ?                 \\
		\end{tabular}
	\end{alltt}

	Use \texttt{bl} to call the built-in \texttt{exit} function, which exits from the program. The value in \texttt{r0} is the returncode.

	The value of \texttt{pc} is restored for the upstream caller (we'll worry more about this in later chapters)

\end{frame}






\Subsection{Memory Diagrams}


\Subsection{Automated Testing}






