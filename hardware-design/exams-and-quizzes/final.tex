\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb, amsmath,graphicx,hyperref,xcolor}

\setlength{\parindent}{0in}
\setlength{\parskip}{1em}

\usepackage{fancyhdr}
\rhead{}

\pagestyle{fancy}
\lhead{St Olaf College}
\chead{CS 241}
\rhead{Spring 2024}

\cfoot{\thepage}

\begin{document}

Name: \makebox[3in]{\hrulefill
%NAME
\hrulefill}

\vfill

\begin{center}
{\huge Final Exam}
\end{center}

\begin{itemize}

    \item This exam covers only the standards where you have not yet demonstrated proficiency.
    \item Extra paper is available. 
    \item I have confidence in you!
\end{itemize}

\vfill

I pledge my honor that on this examination I have neither given nor received assistance not explicitly approved by the professor and that I have seen no dishonest work 

\hfill Signed: \makebox[3in]{\hrulefill}

$\square$\quad I have intentionally not signed the pledge. (check only if appropriate)
\newpage

%BEGIN_DR

\section*{Data Representation}

\begin{enumerate}
\item Convert the hexadecimal number \texttt{0xBEEF} directly to unsigned binary (do not convert to decimal in between).
\vfill

\item Compute the following addition of two's complement binary integers: \texttt{0b00111000 + 0b11101001}. Then convert the values to decimal and confirm your result.
\vfill

\item Write the string ``\texttt{Beef!}'' as a sequence of ASCII values. How many bytes would you need to store it? An ASCII table is included on the next page.
\vfill
\end{enumerate}

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

\includegraphics[width=\textwidth]{wikimedia-ascii-table.png}

\newpage

%END_DR

%BEGIN_LR

\section*{Logic Representation}

\begin{enumerate}
\item Draw a logic circuit with two inputs and one output. Regardless of the input values, the output should always be true.
\vfill

\item Let $f(A, B, C)$ be true if $A$, $B$, and $C$ are all true, false otherwise. Write $f$ in terms of the basic boolean functions AND, OR, NOT, NAND, NOR, and/or XOR. 
\vfill

\item Draw a logic circuit representing the sum of two one-bit unsigned binary numbers: \texttt{0bA + 0bB = 0bCD}. There should be two input bits (\texttt{A} and \texttt{B}) and two output bits (\texttt{C} and \texttt{D}). Also produce the truth table for this circuit.
\vfill
\end{enumerate}

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

%END_LR

%BEGIN_HC

\section*{Hardware Components}

\begin{enumerate}
\item What are cores, processes, and threads? How do they relate, and how are they different?
\vfill

\item Your Raspberry Pi has a 64-bit CPU with a clock speed of 1.5GHz. What do these numbers mean?
\vfill

\item What is one similarity between registers and main memory? What is one difference?
\vfill
\end{enumerate}

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

%END_HC

%BEGIN_HI

\section*{Hardware Interactions}


\begin{enumerate}
\item What are the address bus, control bus, and data bus? What sort of information does each carry?
\vfill

\item Briefly explain each phase of the fetch-decode-execute-store cycle. How does this cycle relate to CPU pipelining?
\vfill

\end{enumerate}

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

%END_HI

%BEGIN_MD

\section*{Memory Diagrams}

The following page has an Assembly program. It does the following:
\begin{itemize}
    \item Allocate two local variables: \texttt{x} and \texttt{x\_squared}
    \item Store a value to \texttt{x}
    \item Send the \underline{addresses} of both variables to the function \texttt{square\_by\_address}
    \item The function loads \texttt{x}, computes its square, and stores it in \texttt{x\_squared}
    \item Back in main, load the values and print them
\end{itemize}

The output looks like:
\begin{verbatim}
    16 squared is 256
\end{verbatim}

Please draw a memory diagram showing the values in registers and main memory at the indicated line. In cases where you don't know the literal value, write what it is --- for example, ``old lr". 


\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

\begin{verbatim}
    .section .rodata
output: .ascii "%d squared is %d\n\0"

    .text
square_by_address:
    push {fp, lr}
    add fp, sp, #4
    @ load value from input address
    ldr r3, [r0]
    @ square it and store the result
    mul r2, r3, r3
    str r2, [r1]
    mov r0, #0
    @               STOP HERE FOR MEMORY DIAGRAM
    pop {fp, pc}

    .global main
main: 
    push {fp, lr}
    add fp, sp, #4
    sub sp, sp, #8
    @ fp-8 is x, fp-12 is x_squared
    mov r0, #16
    str r0, [fp, #-8]
    @ pass the addresses to the function
    sub r0, fp, #8
    sub r1, fp, #12
    bl square_by_address
    @ load the values and print them
    ldr r1, [fp, #-8]
    ldr r2, [fp, #-12]
    ldr r0, output_ptr
    bl printf
    mov r0, #0
    sub sp, fp, #4
    pop {fp, pc}

output_ptr: .word output
\end{verbatim}

%END_MD

%BEGIN_AP1

\section*{Assembly Programming I}

The following page has the skeleton of an Assembly program with comments. The program does the following:
\begin{itemize}
    \item Create global variables \texttt{n\_sandwiches} and \texttt{n\_slices}
    \item Use \texttt{printf} to ask the user how many sandwiches they have
    \item Use \texttt{scanf} to accept a value and store it to \texttt{n\_sandwiches}
    \item Multiply the value by two and store it in \texttt{n\_slices}
    \item Use \texttt{printf} to report the number of slices of bread
\end{itemize}

For example:
\begin{verbatim}
    How many sandwiches do you have? 4
    That's 8 slices of bread!
\end{verbatim}

Please fill in the missing code

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

\begin{verbatim}
@ global constants



@ global variables



@ main


    
    @ stack frame setup, no local variables



    @ print the prompt



    @ read the value n_sandwiches



    @ compute n_slices and store the value



    @ load n_slices and print the reply



    @ stack frame teardown, return zero



@ pointers
\end{verbatim}

%END_AP1

%BEGIN_AP2

\section*{Assembly Programming II}

The following page has the skeleton of an Assembly program with comments. The program does the following:
\begin{itemize}
    \item Allocate local variables \texttt{x} and \texttt{x\_plus\_two} in \texttt{main}
    \item Store the value \texttt{12} in \texttt{x}
    \item Call the function \texttt{add\_one} with input \texttt{x}
    \item Call the function \texttt{add\_one} again on the return value from the first call
    \item Store the final result in \texttt{x\_plus\_two}
\end{itemize}

Please fill in the missing code

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

\begin{verbatim}
@ function add_one



    @ return input + 1



@ function main


    
    @ stack frame setup, two local variables



    @ store initial value for x



    @ call add_one



    @ call add_one again



    @ store x_plus_two



    @ stack frame teardown, return 0



\end{verbatim}

\section*{Standard: Assembly Programming III}

%END_AP2

%BEGIN_AP3

The following page has the skeleton of an Assembly program that adds up the numbers from 1 to 1000. Please fill in the missing code. 

Note: there are a few different ways to write a loop. Your code does not need to line up exactly with the comments.

\vfill

\rule[1ex]{\textwidth}{.1pt}

$\square$ \textbf{P}: You have demonstrated proficiency. Full credit. Well done!

$\square$ \textbf{S}: Partial proficiency. Half credit

$\square$ \textbf{I}: You have not yet demonstrated proficiency

\newpage

\begin{verbatim}
    .section .rodata
result: .ascii "The sum from 0 to 1000 is: %d\n\0"

    .text
    .global main
main: 
    @ stack frame setup, no local variables
    push {fp, lr}
    add fp, sp, #4
    @ initialize loop counter and sum




    @ increment loop counter



    
    @ update the sum


    
    
    @ check loop condition, maybe repeat



    
    @ report result
    ldr r0, result_ptr
    mov r1, r5
    bl printf
    @ return 0, stack frame teardown
    mov r0, #0
    pop {fp, pc}

result_ptr: .word result
\end{verbatim}

%END_AP3

\end{document}
